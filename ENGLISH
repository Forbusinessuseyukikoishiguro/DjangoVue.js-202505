# Complete Guide to Django & Vue.js Unit Testing Implementation
## Expert Engineer Ogasawara-sensei's Guide for Junior Developers

### Introduction

This article provides detailed explanations and implementation examples for basic unit testing in Django and Vue.js, based on the consultation between Yukiko Ishiguro and senior engineer Ryota Ogasawara. This guide is designed as practical knowledge that junior engineers can use in real development environments, with line-by-line code explanations.

---

## 📚 Basic Testing Concepts

### Why Are Unit Tests Important?

**Key Points from Ogasawara-sensei:**
Unit tests are important for the following reasons:

1. **Early Bug Detection** - Find and fix bugs during development, reducing repair costs
2. **Safe Refactoring** - Ensure behavior when changing code
3. **Documentation Role** - Test code serves as specification documentation
4. **Improved Development Efficiency** - Reduce manual testing time

### Basic Test Writing

**Django Version:**
```python
# Django - Simple assertion test
from django.test import TestCase  # Import Django's test class

class BasicTest(TestCase):  # Inherit from TestCase class
    def test_simple_assertion(self):  # Test methods must start with test_
        result = 2 + 2  # Execute the process to be tested
        self.assertEqual(result, 4)  # Compare expected and actual values
```

**Vue.js Version:**
```javascript
// Vue.js - Basic test
test('Simple calculation test', () => {  // Define test case
    const result = 2 + 2  // Execute the process to be tested
    expect(result).toBe(4)  // Compare expected and actual values
})
```

---

## 🧪 Pattern 1: Testing Simple Functions

### Django Implementation Example

**Code to Test (utils.py):**
```python
def calculate_tax(price, tax_rate=0.1):
    """
    Function to calculate tax-inclusive price
    Args:
        price (float): Tax-exclusive price
        tax_rate (float): Tax rate (default: 0.1 = 10%)
    Returns:
        float: Tax-inclusive price
    """
    return price * (1 + tax_rate)  # Calculate tax-inclusive price

def format_phone_number(phone):
    """
    Function to format phone numbers
    Args:
        phone (str): Input phone number
    Returns:
        str: Phone number with hyphens and spaces removed
    """
    return phone.replace('-', '').replace(' ', '')  # Remove hyphens and spaces
```

**Ogasawara-sensei's Recommended Test Code:**
```python
from django.test import TestCase
from .utils import calculate_tax, format_phone_number

class UtilsTest(TestCase):
    """Test class for utility functions"""
    
    def test_calculate_tax_normal_case(self):
        """Normal case test for tax calculation"""
        # Test basic tax calculation
        result = calculate_tax(1000, 0.1)  # 1000 yen, 10% tax rate
        self.assertEqual(result, 1100.0)  # Expected: 1100 yen
        
        # Test with different tax rate
        result = calculate_tax(100, 0.08)  # 100 yen, 8% tax rate
        self.assertEqual(result, 108.0)  # Expected: 108 yen
    
    def test_calculate_tax_boundary_values(self):
        """Boundary value test for tax calculation"""
        # When price is 0
        result = calculate_tax(0, 0.1)  # 0 yen, 10% tax rate
        self.assertEqual(result, 0.0)  # Expected: 0 yen
        
        # When tax rate is 0%
        result = calculate_tax(1000, 0)  # 1000 yen, 0% tax rate
        self.assertEqual(result, 1000.0)  # Expected: 1000 yen
        
        # Check default tax rate
        result = calculate_tax(1000)  # Tax rate omitted (default 10%)
        self.assertEqual(result, 1100.0)  # Expected: 1100 yen
    
    def test_calculate_tax_edge_cases(self):
        """Edge case test for tax calculation"""
        # Negative price (depending on specification)
        result = calculate_tax(-100, 0.1)  # -100 yen, 10% tax rate
        self.assertEqual(result, -110.0)  # Expected: -110 yen
        
        # High tax rate
        result = calculate_tax(1000, 1.0)  # 1000 yen, 100% tax rate
        self.assertEqual(result, 2000.0)  # Expected: 2000 yen
    
    def test_format_phone_number_normal_case(self):
        """Normal case test for phone number formatting"""
        # Phone number with hyphens
        result = format_phone_number('090-1234-5678')
        self.assertEqual(result, '09012345678')  # Hyphens removed
        
        # Phone number with spaces
        result = format_phone_number('090 1234 5678')
        self.assertEqual(result, '09012345678')  # Spaces removed
        
        # Mixed hyphens and spaces
        result = format_phone_number('090-1234 5678')
        self.assertEqual(result, '09012345678')  # Both removed
    
    def test_format_phone_number_edge_cases(self):
        """Edge case test for phone number formatting"""
        # Empty string
        result = format_phone_number('')
        self.assertEqual(result, '')  # Remains empty string
        
        # Numbers only (already formatted)
        result = format_phone_number('09012345678')
        self.assertEqual(result, '09012345678')  # No change
        
        # With special characters
        result = format_phone_number('090-1234-5678#123')
        self.assertEqual(result, '09012345678#123')  # Only hyphens removed
```

### Vue.js Implementation Example

**Code to Test (utils.js):**
```javascript
/**
 * Function to format amount as Japanese yen currency
 * @param {number} amount - Amount to format
 * @returns {string} - Formatted currency string
 */
export function formatCurrency(amount) {
    return new Intl.NumberFormat('ja-JP', {  // Specify Japanese locale
        style: 'currency',  // Specify currency format
        currency: 'JPY'     // Specify Japanese yen
    }).format(amount)  // Format the amount
}

/**
 * Function to validate email address
 * @param {string} email - Email address to check
 * @returns {boolean} - true if valid email address
 */
export function isValidEmail(email) {
    // Basic email address regex pattern
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    return regex.test(email)  // Test with regex
}
```

**Ogasawara-sensei's Recommended Test Code:**
```javascript
// Vue.js test file (utils.test.js)
import { formatCurrency, isValidEmail } from './utils.js'

describe('Utils function tests', () => {  // Define test suite
    
    describe('formatCurrency function', () => {  // formatCurrency function test group
        
        test('Format normal amount', () => {
            // Test basic amount
            const result = formatCurrency(1000)  // Format 1000 yen
            expect(result).toBe('￥1,000')  // Expected: ￥1,000
        })
        
        test('Format amount with decimal', () => {
            // Amount with decimal (usually rounded)
            const result = formatCurrency(1000.5)  // Format 1000.5 yen
            expect(result).toBe('￥1,001')  // Expected: ￥1,001 (rounded)
        })
        
        test('Format zero amount', () => {
            // Boundary value test: 0 yen
            const result = formatCurrency(0)  // Format 0 yen
            expect(result).toBe('￥0')  // Expected: ￥0
        })
        
        test('Format negative amount', () => {
            // Negative amount case
            const result = formatCurrency(-1000)  // Format -1000 yen
            expect(result).toBe('-￥1,000')  // Expected: -￥1,000
        })
        
        test('Format large amount', () => {
            // Large amount test
            const result = formatCurrency(1234567)  // Format 1,234,567 yen
            expect(result).toBe('￥1,234,567')  // Expected: ￥1,234,567
        })
    })
    
    describe('isValidEmail function', () => {  // isValidEmail function test group
        
        test('Valid email addresses', () => {
            // Normal case: basic email address
            expect(isValidEmail('test@example.com')).toBe(true)
            
            // Normal case: with subdomain
            expect(isValidEmail('user@mail.example.com')).toBe(true)
            
            // Normal case: with numbers
            expect(isValidEmail('user123@example.com')).toBe(true)
            
            // Normal case: username with dot
            expect(isValidEmail('first.last@example.com')).toBe(true)
        })
        
        test('Invalid email addresses', () => {
            // Error case: no @ symbol
            expect(isValidEmail('testexample.com')).toBe(false)
            
            // Error case: no domain
            expect(isValidEmail('test@')).toBe(false)
            
            // Error case: no username
            expect(isValidEmail('@example.com')).toBe(false)
            
            // Error case: no extension
            expect(isValidEmail('test@example')).toBe(false)
            
            // Error case: empty string
            expect(isValidEmail('')).toBe(false)
            
            // Error case: contains space
            expect(isValidEmail('test @example.com')).toBe(false)
            
            // Error case: multiple @ symbols
            expect(isValidEmail('test@@example.com')).toBe(false)
        })
    })
})
```

---

## 🔧 Pattern 2: Testing Methods with Return Values

### Django Implementation Example

**Code to Test (models.py):**
```python
from django.db import models
from datetime import date

class User(models.Model):
    """User model"""
    first_name = models.CharField(max_length=50)  # First name
    last_name = models.CharField(max_length=50)   # Last name
    birth_date = models.DateField()               # Birth date
    
    def get_full_name(self):
        """
        Method to return full name
        Returns:
            str: Full name in "first_name last_name" format
        """
        return f"{self.first_name} {self.last_name}".strip()  # Remove leading/trailing spaces
    
    def get_age(self):
        """
        Method to calculate and return age
        Returns:
            int: Current age
        """
        today = date.today()  # Get today's date
        return today.year - self.birth_date.year  # Calculate age by year difference
    
    def __str__(self):
        return self.get_full_name()  # Use full name as string representation
```

**Ogasawara-sensei's Recommended Test Code:**
```python
from django.test import TestCase
from datetime import date
from .models import User

class UserModelTest(TestCase):
    """User model test class"""
    
    def setUp(self):
        """Setup method called before each test method"""
        # Create test user data
        self.user = User.objects.create(
            first_name='Taro',           # Set first name
            last_name='Tanaka',          # Set last name
            birth_date=date(1990, 5, 15)  # Set birth date (May 15, 1990)
        )
    
    def test_get_full_name_normal_case(self):
        """Normal case test for full name retrieval"""
        # Basic full name retrieval
        full_name = self.user.get_full_name()  # Get full name
        self.assertEqual(full_name, 'Taro Tanaka')  # Expected: 'Taro Tanaka'
    
    def test_get_full_name_with_spaces(self):
        """Test names with whitespace characters"""
        # When names contain whitespace characters
        user_with_spaces = User.objects.create(
            first_name=' Hanako ',        # First name with leading/trailing spaces
            last_name=' Yamada ',         # Last name with leading/trailing spaces
            birth_date=date(1985, 3, 20)
        )
        
        full_name = user_with_spaces.get_full_name()  # Get full name
        self.assertEqual(full_name, ' Hanako   Yamada ')  # strip() only removes outer spaces
    
    def test_get_full_name_empty_names(self):
        """Test empty names"""
        # When first name is empty string
        user_empty_first = User.objects.create(
            first_name='',              # Empty first name
            last_name='Sato',           # Normal last name
            birth_date=date(1995, 1, 1)
        )
        
        full_name = user_empty_first.get_full_name()  # Get full name
        self.assertEqual(full_name, ' Sato')  # Expected: ' Sato' (space at beginning)
        
        # When last name is empty string
        user_empty_last = User.objects.create(
            first_name='Jiro',          # Normal first name
            last_name='',               # Empty last name
            birth_date=date(1995, 1, 1)
        )
        
        full_name = user_empty_last.get_full_name()  # Get full name
        self.assertEqual(full_name, 'Jiro ')  # Expected: 'Jiro ' (space at end)
    
    def test_get_age_calculation(self):
        """Age calculation test"""
        # Age calculation based on 2025 (current year - birth year)
        age = self.user.get_age()  # Get age
        expected_age = date.today().year - 1990  # Calculate expected age
        self.assertEqual(age, expected_age)  # Check if age is calculated correctly
    
    def test_get_age_different_birth_years(self):
        """Age calculation test for different birth years"""
        # User born in 2000
        user_2000 = User.objects.create(
            first_name='Saburo',
            last_name='Suzuki',
            birth_date=date(2000, 12, 31)  # Born December 31, 2000
        )
        
        age_2000 = user_2000.get_age()  # Get age
        expected_age_2000 = date.today().year - 2000  # Calculate expected age
        self.assertEqual(age_2000, expected_age_2000)  # Verify age
        
        # User born in 1980
        user_1980 = User.objects.create(
            first_name='Shiro',
            last_name='Takahashi',
            birth_date=date(1980, 1, 1)   # Born January 1, 1980
        )
        
        age_1980 = user_1980.get_age()  # Get age
        expected_age_1980 = date.today().year - 1980  # Calculate expected age
        self.assertEqual(age_1980, expected_age_1980)  # Verify age
    
    def test_string_representation(self):
        """String representation test"""
        # Test __str__ method
        user_str = str(self.user)  # String conversion
        self.assertEqual(user_str, 'Taro Tanaka')  # Same as get_full_name() result
```

### Vue.js Implementation Example

**Code to Test (UserComponent.vue):**
```javascript
export default {
    name: 'UserComponent',  // Component name
    
    data() {
        return {
            firstName: '',  // First name data
            lastName: ''    // Last name data
        }
    },
    
    methods: {
        /**
         * Method to return full name
         * @returns {string} Full name
         */
        getFullName() {
            // Combine first and last name to create full name
            return `${this.firstName} ${this.lastName}`.trim()  // Remove leading/trailing spaces
        },
        
        /**
         * Age check (18 years or older)
         * @param {string} birthDate - Birth date (YYYY-MM-DD format)
         * @returns {boolean} true if 18 years or older
         */
        validateAge(birthDate) {
            const today = new Date()  // Get current date
            const birth = new Date(birthDate)  // Convert birth date to Date object
            const age = today.getFullYear() - birth.getFullYear()  // Calculate age by year difference
            return age >= 18  // Check if 18 years or older
        }
    }
}
```

**Ogasawara-sensei's Recommended Test Code:**
```javascript
// Vue.js test file (UserComponent.test.js)
import { shallowMount } from '@vue/test-utils'  // Import Vue Test Utils
import UserComponent from './UserComponent.vue'  // Import component to test

describe('UserComponent', () => {  // UserComponent test suite
    
    let wrapper  // Variable to store wrapper
    
    beforeEach(() => {  // Setup called before each test
        // Mount component with shallowMount
        wrapper = shallowMount(UserComponent)
    })
    
    afterEach(() => {  // Cleanup called after each test
        // Destroy wrapper to prevent memory leaks
        wrapper.unmount()
    })
    
    describe('getFullName method', () => {  // getFullName method test group
        
        test('Normal full name retrieval', async () => {
            // Set data
            await wrapper.setData({
                firstName: 'Taro',  // Set first name
                lastName: 'Tanaka'  // Set last name
            })
            
            // Execute method
            const result = wrapper.vm.getFullName()  // Access method via vm
            expect(result).toBe('Taro Tanaka')  // Expected: 'Taro Tanaka'
        })
        
        test('Empty string case', async () => {
            // Set both to empty strings
            await wrapper.setData({
                firstName: '',  // Empty first name
                lastName: ''    // Empty last name
            })
            
            const result = wrapper.vm.getFullName()  // Execute method
            expect(result).toBe('')  // Expected: '' (empty string)
        })
        
        test('One empty string case', async () => {
            // Set only first name
            await wrapper.setData({
                firstName: 'Hanako',  // Set first name
                lastName: ''          // Last name is empty
            })
            
            const result = wrapper.vm.getFullName()  // Execute method
            expect(result).toBe('Hanako')  // Expected: 'Hanako' (trim() removes spaces)
            
            // Set only last name
            await wrapper.setData({
                firstName: '',       // First name is empty
                lastName: 'Yamada'   // Set last name
            })
            
            const result2 = wrapper.vm.getFullName()  // Execute method
            expect(result2).toBe('Yamada')  // Expected: 'Yamada' (trim() removes spaces)
        })
        
        test('Case with whitespace characters', async () => {
            // Set data with leading/trailing spaces
            await wrapper.setData({
                firstName: ' Jiro ',  // First name with leading/trailing spaces
                lastName: ' Sato '    // Last name with leading/trailing spaces
            })
            
            const result = wrapper.vm.getFullName()  // Execute method
            expect(result).toBe(' Jiro   Sato ')  // Middle spaces remain, only outer spaces trimmed
        })
    })
    
    describe('validateAge method', () => {  // validateAge method test group
        
        test('18 years or older case', () => {
            // Born in 1990 (currently about 35 years old)
            const result = wrapper.vm.validateAge('1990-05-15')  // Execute method
            expect(result).toBe(true)  // Expected: true (18 years or older)
        })
        
        test('Under 18 years case', () => {
            // Born in 2020 (currently about 5 years old)
            const result = wrapper.vm.validateAge('2020-01-01')  // Execute method
            expect(result).toBe(false)  // Expected: false (under 18)
        })
        
        test('Exactly 18 years old case', () => {
            // Dynamically calculate year that is 18 years ago from current year
            const currentYear = new Date().getFullYear()  // Get current year
            const eighteenYearsAgo = currentYear - 18     // Calculate year 18 years ago
            const birthDate = `${eighteenYearsAgo}-01-01` // January 1, 18 years ago
            
            const result = wrapper.vm.validateAge(birthDate)  // Execute method
            expect(result).toBe(true)  // Expected: true (exactly 18 years old)
        })
        
        test('Boundary value test (17 and 19 years old)', () => {
            const currentYear = new Date().getFullYear()  // Get current year
            
            // 17 years old (under 18)
            const seventeenYearsAgo = currentYear - 17   // Year 17 years ago
            const result17 = wrapper.vm.validateAge(`${seventeenYearsAgo}-01-01`)
            expect(result17).toBe(false)  // Expected: false (17 is under 18)
            
            // 19 years old (18 or older)
            const nineteenYearsAgo = currentYear - 19    // Year 19 years ago
            const result19 = wrapper.vm.validateAge(`${nineteenYearsAgo}-01-01`)
            expect(result19).toBe(true)   // Expected: true (19 is 18 or older)
        })
        
        test('Invalid date string case', () => {
            // Invalid date string
            const result = wrapper.vm.validateAge('invalid-date')  // Invalid date
            expect(result).toBe(false)  // NaN comparison result is false
        })
    })
})
```

---

## 🏗️ Pattern 3: Testing Class Methods

### Django Implementation Example

**Code to Test (models.py):**
```python
from django.db import models
from datetime import date

class UserManager(models.Manager):
    """Custom user manager"""
    
    @classmethod
    def create_adult_user(cls, **kwargs):
        """
        Class method to create users who are 18 years or older only
        Args:
            **kwargs: Fields required for user creation
        Returns:
            User: Created user object
        Raises:
            ValueError: When birth date is not set or under 18 years old
        """
        birth_date = kwargs.get('birth_date')  # Get birth date
        
        # Check if birth date is set
        if not birth_date:
            raise ValueError('Birth date is required')  # Raise exception
        
        # Calculate age
        age = date.today().year - birth_date.year  # Current year - birth year
        
        # Raise exception if under 18
        if age < 18:
            raise ValueError('Users under 18 cannot be registered')
        
        # Create user if conditions are met
        return cls.create(**kwargs)  # Call parent class create method

class User(models.Model):
    """User model"""
    first_name = models.CharField(max_length=50)  # First name
    last_name = models.CharField(max_length=50)   # Last name
    birth_date = models.DateField()               # Birth date
    
    objects = UserManager()  # Use custom manager
    
    def __str__(self):
        return f"{self.first_name} {self.last_name}"
```

**Ogasawara-sensei's Recommended Test Code:**
```python
from django.test import TestCase
from datetime import date
from .models import User

class UserManagerTest(TestCase):
    """UserManager test class"""
    
    def test_create_adult_user_success(self):
        """Normal case test for adult user creation"""
        # Create user who is 18 or older
        user = User.objects.create_adult_user(
            first_name='Taro',           # Specify first name
            last_name='Tanaka',          # Specify last name
            birth_date=date(1990, 5, 15)  # Born in 1990 (30+ years old)
        )
        
        # Check if user was created successfully
        self.assertIsNotNone(user)  # Confirm user is not None
        self.assertEqual(user.first_name, 'Taro')  # Check if first name is set correctly
        self.assertEqual(user.last_name, 'Tanaka')   # Check if last name is set correctly
        self.assertEqual(user.birth_date, date(1990, 5, 15))  # Check if birth date is set correctly
        
        # Check if saved to database
        self.assertTrue(User.objects.filter(pk=user.pk).exists())  # Confirm exists in DB
    
    def test_create_adult_user_boundary_18_years_old(self):
        """Test creating exactly 18-year-old user"""
        # Calculate date 18 years ago from current year
        current_year = date.today().year  # Get current year
        birth_year = current_year - 18    # Calculate year 18 years ago
        birth_date_18 = date(birth_year, 1, 1)  # January 1, 18 years ago
        
        # Create exactly 18-year-old user
        user = User.objects.create_adult_user(
            first_name='Hanako',
            last_name='Yamada',
            birth_date=birth_date_18  # Birth date for 18 years old
        )
        
        # Confirm successful creation
        self.assertIsNotNone(user)  # Confirm creation success
        self.assertEqual(user.birth_date, birth_date_18)  # Birth date set correctly
    
    def test_create_adult_user_no_birth_date_error(self):
        """Test error when birth date is not set"""
        # Try to create user without setting birth date
        with self.assertRaises(ValueError) as context:  # Expect ValueError to be raised
            User.objects.create_adult_user(
                first_name='Jiro',  # Only first name set
                last_name='Sato'    # Only last name set
                # birth_date intentionally omitted
            )
        
        # Check if error message is correct
        self.assertEqual(str(context.exception), 'Birth date is required')
    
    def test_create_adult_user_underage_error(self):
        """Test error when creating underage user"""
        # Try to create user under 18
        with self.assertRaises(ValueError) as context:  # Expect ValueError to be raised
            User.objects.create_adult_user(
                first_name='Saburo',
                last_name='Suzuki',
                birth_date=date(2010, 1, 1)  # Born in 2010 (about 15 years old)
            )
        
        # Check if error message is correct
        self.assertEqual(str(context.exception), 'Users under 18 cannot be registered')
    
    def test_create_adult_user_boundary_17_years_old(self):
        """Test error when creating 17-year-old user"""
        # Calculate date 17 years ago from current year
        current_year = date.today().year  # Get current year
        birth_year = current_year - 17    # Calculate year 17 years ago
        birth_date_17 = date(birth_year, 12, 31)  # December 31, 17 years ago
        
        # Try to create 17-year-old user (should error)
        with self.assertRaises(ValueError) as context:
            User.objects.create_adult_user(
                first_name='Shiro',
                last_name='Takahashi',
                birth_date=birth_date_17  # Birth date for 17 years old
            )
        
        # Confirm correct error message is output
        self.assertEqual(str(context.exception), 'Users under 18 cannot be registered')
    
    def test_create_adult_user_multiple_users(self):
        """Test creating multiple users"""
        # Create multiple adult users
        users_data = [
            {
                'first_name': 'Ichiro',
                'last_name': 'Tokyo',
                'birth_date': date(1985, 3, 20)
            },
            {
                'first_name': 'Jiro',
                'last_name': 'Osaka',
                'birth_date': date(1992, 7, 10)
            },
            {
                'first_name': 'Saburo',
                'last_name': 'Nagoya',
                'birth_date': date(1988, 11, 5)
            }
        ]
        
        created_users = []  # List of created users
        
        # Create user for each user data
        for user_data in users_data:
            user = User.objects.create_adult_user(**user_data)  # Create user
            created_users.append(user)  # Add to list
        
        # Check if all users were created
        self.assertEqual(len(created_users), 3)  # 3 users created?
        
        # Check if saved to database
        db_users = User.objects.all()  # Get all users
        self.assertEqual(db_users.count(), 3)  # 3 users saved in database?
        
        # Check if each user's information is correct
        for i, user in enumerate(created_users):
            expected_data = users_data[i]  # Expected data
            self.assertEqual(user.first_name, expected_data['first_name'])
            self.assertEqual(user.last_name, expected_data['last_name'])
            self.assertEqual(user.birth_date, expected_data['birth_date'])
```

---

## 🎯 Testing Best Practices

### Important Points from Ogasawara-sensei

#### 1. Test Case Coverage
```python
# ✅ Good example: Test normal cases, error cases, and boundary values comprehensively
def test_calculate_tax_comprehensive(self):
    # Normal case
    self.assertEqual(calculate_tax(1000, 0.1), 1100.0)
    
    # Boundary values
    self.assertEqual(calculate_tax(0, 0.1), 0.0)      # Price 0
    self.assertEqual(calculate_tax(1000, 0), 1000.0)  # Tax rate 0
    
    # Error cases
    self.assertEqual(calculate_tax(-100, 0.1), -110.0)  # Negative price

# ❌ Bad example: Only normal case tested, boundary values and error cases untested
def test_calculate_tax_insufficient(self):
    self.assertEqual(calculate_tax(1000, 0.1), 1100.0)  # This alone is insufficient
```

#### 2. Test Method Naming Convention
```python
# ✅ Good example: Clear what is being tested
def test_get_full_name_with_empty_first_name(self):
    """Test full name retrieval when first name is empty string"""
    pass

def test_create_adult_user_raises_error_when_underage(self):
    """Test that error is raised for underage users"""
    pass

# ❌ Bad example: Unclear what is being tested
def test_user_method(self):
    pass

def test_error_case(self):
    pass
```

#### 3. Setup and Cleanup
```python
# ✅ Good example: Manage test data with setUp/tearDown methods
class UserModelTest(TestCase):
    def setUp(self):
        """Preparation process executed before each test"""
        self.user = User.objects.create(
            first_name='Test',
            last_name='Taro',
            birth_date=date(1990, 1, 1)
        )
    
    def tearDown(self):
        """Cleanup process executed after each test"""
        # Usually unnecessary in TestCase as DB is automatically cleaned up
        pass
    
    def test_user_method(self):
        # Use self.user for testing
        result = self.user.get_full_name()
        self.assertEqual(result, 'Test Taro')
```

#### 4. Assertion Selection
```python
# ✅ Use appropriate assertion methods
def test_assertions_examples(self):
    # Equality test
    self.assertEqual(actual, expected)
    
    # Boolean value test
    self.assertTrue(condition)
    self.assertFalse(condition)
    
    # None value test
    self.assertIsNone(value)
    self.assertIsNotNone(value)
    
    # Exception test
    with self.assertRaises(ValueError):
        risky_function()
    
    # Collection test
    self.assertIn(item, collection)
    self.assertListEqual(list1, list2)
```

---

## 🌟 Summary

Important points learned from Ogasawara-sensei about unit testing:

### 1. **Three Principles of Test Design**
- **Normal Cases**: Verify behavior with expected input
- **Error Cases**: Verify behavior with unexpected input  
- **Boundary Values**: Verify behavior at condition boundaries

### 2. **Code Quality Improvement**
- Write test code as carefully as main code
- Express specifications through test method names
- Test one aspect per test method

### 3. **Continuous Improvement**
- Review test code when tests fail
- Update tests simultaneously during refactoring
- Be aware of test coverage to improve comprehensiveness

### 4. **Team Development Utilization**
- Test code serves as documentation
- Makes it easier for new members to understand code
- Creates environment for safe code changes

---

## 💬 Additional Expert Advice from Ogasawara-sensei

### 小笠原先生からの追加アドバイス (Original Response in Japanese)

> @石黒友季子 【業務用】 様 ご質問いただきありがとうございます！ 
> 
> ■網羅性について 
> 正常系（期待通り動く入力） 
> 境界値（最小値・最大値・ゼロ・空など） 
> 異常系（想定外の入力や例外） 
> を意識してケースを追加していくと良いと思います。 
> 
> また境界値については要件によると思うのでシステムの要件として許容するのかどうかというところで判断するようにし、曖昧な部分を見つけた場合は、そちらは新しい課題になるように考えています。 
> 
> ■戻り値があるメソッドのテスト 
> 戻り値がある場合は、基本的には以下のような流れで良くて場合によってはモックが必要になるかも知れないです。 
> 
> モデルのインスタンス生成→メソッド呼び出し→assert 
> 
> テストコードについて、現在の書き方で問題ないと思います。また正しいテスト自体がプロジェクトによっても変わるので書いていく中で何か問題などありましたら気軽にご相談いただけますと幸いです。

### Expert Advice Translation and Detailed Explanation

**Ogasawara-sensei's Response:**
*"Thank you for your question! Here's my advice on comprehensive testing and method testing approaches."*

#### 🎯 **Comprehensive Test Coverage Strategy**

**Key Testing Categories to Consider:**

1. **Normal Cases** (Expected input that works as intended)
   - Standard use cases with typical valid inputs
   - Common user scenarios and workflows
   - Expected data ranges and formats

2. **Boundary Values** (Minimum/Maximum values, Zero, Empty, etc.)
   - Edge cases at the limits of acceptable input
   - Zero values, empty strings, null/undefined
   - Maximum length strings, largest/smallest numbers
   - First/last elements in collections

3. **Error Cases** (Unexpected input or exceptions)
   - Invalid input formats
   - Out-of-range values
   - Malformed data
   - System errors and exception conditions

**Implementation Example:**
```python
class ComprehensiveTestExample(TestCase):
    def test_user_registration_comprehensive(self):
        # Normal cases
        self.assertTrue(register_user("john@example.com", "ValidPass123"))
        
        # Boundary values
        self.assertFalse(register_user("", "ValidPass123"))  # Empty email
        self.assertFalse(register_user("john@example.com", ""))  # Empty password
        self.assertTrue(register_user("a@b.co", "12345678"))  # Minimum valid email
        
        # Error cases
        self.assertFalse(register_user("invalid-email", "ValidPass123"))  # Invalid format
        with self.assertRaises(ValueError):
            register_user("john@example.com", "weak")  # Password too weak
```

#### 📋 **Requirements-Based Boundary Value Testing**

**Ogasawara-sensei's Key Insight:**
*"Boundary value testing should be determined by system requirements. When you find ambiguous parts, consider them as new issues to be clarified."*

**Practical Approach:**
```python
class BoundaryValueStrategy(TestCase):
    def test_age_validation_based_on_requirements(self):
        # If system requirements specify "18 years or older"
        self.assertTrue(validate_adult_age(18))   # Boundary: exactly 18
        self.assertFalse(validate_adult_age(17))  # Just under boundary
        self.assertTrue(validate_adult_age(19))   # Just over boundary
        
        # Edge cases that may need requirement clarification:
        # - What about users born on leap years?
        # - How to handle different time zones?
        # - Should we consider month/day or just year?
        
        # Document these as potential new requirements if unclear
```

**Requirements Documentation Example:**
```python
def test_price_calculation_requirements_based(self):
    """
    Test based on business requirements:
    - Minimum order: $10.00
    - Maximum order: $10,000.00
    - Tax rate: 8.5%
    - Currency: USD only
    
    Ambiguous requirements to clarify:
    - How to handle fractional cents?
    - International currency support?
    - Different tax rates by location?
    """
    # Clear requirements testing
    self.assertEqual(calculate_total(100.00, 0.085), 108.50)
    
    # Boundary testing
    self.assertRaises(ValueError, calculate_total, 9.99, 0.085)    # Below minimum
    self.assertRaises(ValueError, calculate_total, 10000.01, 0.085)  # Above maximum
```

#### 🔄 **Method Testing with Return Values - Standard Flow**

**Ogasawara-sensei's Recommended Pattern:**
*"For methods with return values, follow this basic flow. Mocks may be necessary in some cases."*

**Standard Testing Flow:**
```
Model Instance Creation → Method Invocation → Assertion
```

**Implementation Examples:**

```python
# Django Model Method Testing
class UserMethodTest(TestCase):
    def test_user_method_standard_flow(self):
        # 1. Model Instance Creation
        user = User.objects.create(
            first_name='John',
            last_name='Doe',
            birth_date=date(1990, 1, 1)
        )
        
        # 2. Method Invocation
        full_name = user.get_full_name()
        
        # 3. Assertion
        self.assertEqual(full_name, 'John Doe')
```

```javascript
// Vue.js Component Method Testing
describe('Component method testing', () => {
    test('standard flow for method with return value', async () => {
        // 1. Component Instance Creation
        const wrapper = shallowMount(UserComponent)
        await wrapper.setData({
            firstName: 'John',
            lastName: 'Doe'
        })
        
        // 2. Method Invocation
        const result = wrapper.vm.getFullName()
        
        // 3. Assertion
        expect(result).toBe('John Doe')
    })
})
```

#### 🎭 **When Mocking Becomes Necessary**

**Scenarios Requiring Mocks:**

1. **External API Calls**
```python
from unittest.mock import patch, Mock

class ExternalServiceTest(TestCase):
    @patch('myapp.services.external_api_client')
    def test_user_data_fetch_with_mock(self, mock_api):
        # Mock external service response
        mock_api.get_user_data.return_value = {
            'id': 123,
            'name': 'John Doe',
            'email': 'john@example.com'
        }
        
        # Test the method that uses external service
        user_service = UserService()
        result = user_service.fetch_user_profile(123)
        
        # Assertions
        self.assertEqual(result['name'], 'John Doe')
        mock_api.get_user_data.assert_called_once_with(123)
```

2. **Database Queries in Complex Scenarios**
```python
class ComplexQueryTest(TestCase):
    @patch('myapp.models.User.objects.filter')
    def test_complex_user_search(self, mock_filter):
        # Mock query result
        mock_filter.return_value = [
            Mock(name='John Doe', age=30),
            Mock(name='Jane Smith', age=25)
        ]
        
        # Test method that performs complex query
        search_service = UserSearchService()
        results = search_service.find_users_by_criteria({'age_range': (20, 35)})
        
        # Assertions
        self.assertEqual(len(results), 2)
        self.assertEqual(results[0].name, 'John Doe')
```

3. **Time-Dependent Logic**
```python
from freezegun import freeze_time

class TimeBasedTest(TestCase):
    @freeze_time("2025-01-15")
    def test_age_calculation_with_fixed_time(self):
        user = User.objects.create(
            first_name='John',
            last_name='Doe',
            birth_date=date(2000, 1, 15)  # Exactly 25 years old
        )
        
        age = user.get_age()
        self.assertEqual(age, 25)  # Predictable result with frozen time
```

#### 🎯 **Project-Specific Testing Approaches**

**Ogasawara-sensei's Important Note:**
*"Your current testing approach is fine. The 'correct' testing approach varies by project, so please feel free to consult me if you encounter any issues as you continue development."*

**Key Considerations by Project Type:**

1. **Enterprise Applications**
   - Heavy focus on integration testing
   - Comprehensive error handling
   - Performance testing for large datasets

2. **Consumer Applications**
   - User experience validation
   - Cross-browser/device compatibility
   - Accessibility testing

3. **API Services**
   - Contract testing
   - Rate limiting validation
   - Security testing

4. **Real-time Applications**
   - Concurrency testing
   - Event ordering validation
   - Performance under load

**Adaptive Testing Strategy:**
```python
class ProjectSpecificTestBase(TestCase):
    """Base test class that can be customized per project"""
    
    def setUp(self):
        """Override in subclasses for project-specific setup"""
        super().setUp()
        self.setup_project_specific_data()
    
    def setup_project_specific_data(self):
        """Override this method in project-specific test classes"""
        pass
    
    def assert_business_rule(self, condition, message):
        """Custom assertion for business rules"""
        self.assertTrue(condition, f"Business rule violated: {message}")

# Project-specific implementation
class ECommerceTestCase(ProjectSpecificTestBase):
    def setup_project_specific_data(self):
        self.test_product = Product.objects.create(
            name="Test Product",
            price=29.99,
            inventory=100
        )
    
    def test_order_processing(self):
        order = Order.create_from_cart(self.test_cart)
        self.assert_business_rule(
            order.total > 0,
            "Order total must be positive"
        )
```

---

## 📚 References

### Django Testing Resources
- [Django Official Documentation - Testing in Django](https://docs.djangoproject.com/en/stable/topics/testing/)
- [Real Python - Testing in Django](https://realpython.com/testing-in-django-part-1-best-practices-and-examples/)
- [TestDriven.io - Django Testing Best Practices](https://testdriven.io/blog/django-unit-testing/)

### Vue.js Testing Resources
- [Vue.js Official - Unit Testing](https://vuejs.org/guide/scaling-up/testing.html)
- [Vue Test Utils Official Documentation](https://test-utils.vuejs.org/)
- [Vue.js Testing Handbook](https://lmiller1990.github.io/vue-testing-handbook/)

---

*This article was created as practical content for real development environments under the guidance of senior engineer Ryota Ogasawara.*
